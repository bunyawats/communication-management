// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: query.sql

package mysql

import (
	"context"
	"database/sql"
)

const createNotificationDetail = `-- name: CreateNotificationDetail :execresult
INSERT INTO notification_detail
    (email, chunk_partition, task_id)
VALUES (?, ?, ?)
`

type CreateNotificationDetailParams struct {
	Email          string
	ChunkPartition string
	TaskID         string
}

func (q *Queries) CreateNotificationDetail(ctx context.Context, arg CreateNotificationDetailParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createNotificationDetail, arg.Email, arg.ChunkPartition, arg.TaskID)
}

const createTask = `-- name: CreateTask :execresult
INSERT INTO task
(task_id, task_name, cron_pattern, input_file_url, task_status, chunk_size)
VALUES (?, ?, ?, ?, ?, ?)
`

type CreateTaskParams struct {
	TaskID       string
	TaskName     string
	CronPattern  string
	InputFileUrl string
	TaskStatus   sql.NullString
	ChunkSize    sql.NullInt32
}

func (q *Queries) CreateTask(ctx context.Context, arg CreateTaskParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createTask,
		arg.TaskID,
		arg.TaskName,
		arg.CronPattern,
		arg.InputFileUrl,
		arg.TaskStatus,
		arg.ChunkSize,
	)
}

const getTaskById = `-- name: GetTaskById :one
SELECT task_id, task_name, cron_pattern, input_file_url, task_status, chunk_size
FROM task
WHERE task_id = ?
`

func (q *Queries) GetTaskById(ctx context.Context, taskID string) (Task, error) {
	row := q.db.QueryRowContext(ctx, getTaskById, taskID)
	var i Task
	err := row.Scan(
		&i.TaskID,
		&i.TaskName,
		&i.CronPattern,
		&i.InputFileUrl,
		&i.TaskStatus,
		&i.ChunkSize,
	)
	return i, err
}

const listAllActiveTasks = `-- name: ListAllActiveTasks :many
SELECT task_id, task_name, cron_pattern, input_file_url, task_status, chunk_size
FROM task
WHERE task_status != "INACTIVE"
`

func (q *Queries) ListAllActiveTasks(ctx context.Context) ([]Task, error) {
	rows, err := q.db.QueryContext(ctx, listAllActiveTasks)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Task
	for rows.Next() {
		var i Task
		if err := rows.Scan(
			&i.TaskID,
			&i.TaskName,
			&i.CronPattern,
			&i.InputFileUrl,
			&i.TaskStatus,
			&i.ChunkSize,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAllChunkPartition = `-- name: ListAllChunkPartition :many
SELECT chunk_partition
FROM notification_detail
WHERE task_id = ?
GROUP BY chunk_partition
`

func (q *Queries) ListAllChunkPartition(ctx context.Context, taskID string) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, listAllChunkPartition, taskID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var chunk_partition string
		if err := rows.Scan(&chunk_partition); err != nil {
			return nil, err
		}
		items = append(items, chunk_partition)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listNotiEmailByChunk = `-- name: ListNotiEmailByChunk :many
SELECT email
FROM notification_detail
WHERE chunk_partition = ?
`

func (q *Queries) ListNotiEmailByChunk(ctx context.Context, chunkPartition string) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, listNotiEmailByChunk, chunkPartition)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var email string
		if err := rows.Scan(&email); err != nil {
			return nil, err
		}
		items = append(items, email)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTaskStatus = `-- name: UpdateTaskStatus :execresult
UPDATE task
SET task_status=?
WHERE task_id = ?
`

type UpdateTaskStatusParams struct {
	TaskStatus sql.NullString
	TaskID     string
}

func (q *Queries) UpdateTaskStatus(ctx context.Context, arg UpdateTaskStatusParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, updateTaskStatus, arg.TaskStatus, arg.TaskID)
}
